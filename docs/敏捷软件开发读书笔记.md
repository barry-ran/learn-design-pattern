
# 第一部分 敏捷开发
***强调人的重要性，具有合作精神的、自组织的团队要比其它的原则、模式、实践经验等来的重要。***
```
过程和方法对于项目的结果只有次要的影响，首要的影响是人。
```
## 第一章 敏捷实践
***项目开发流程需要良好实践的指导，否则会带来噩梦。***
```
缺乏有效的实践会导致不可预测性、重复的错误以及努力的白白浪费。延期的进度、增加的预算和低劣的质量致使客户对我们丧失信心。
更长时间的工作却生产出更加低劣的软件产品，也使得开发人员感到沮丧。
```
### 1.1 敏捷联盟
为了解决上述问题，一批业界专家聚集在一起概括出了一些可以让软件开发团队具有快速工作、响应变化能力的价值观( value)和原则，他们称自己为 ***敏捷联盟*** 。在随后的几个月中,他们创建出了一份价值观声明，也就是 ***敏捷联盟宣言*** 。

#### 敏捷联盟宣言
1. ***个体和交互胜过过程和工具***
   
    ***人是获得成功的最为重要的因素。*** 而且人的合作、沟通以及交互能力要比单纯的编码能力重要。

    ***合适的工具对于成功来说非常重要。*** 建议从小工具开始，尝试一个工具，只有当它无法适用时才去更换它。
  ```
  记住,团队的构建要比环境的构建重要得多。许多团队和管理者就犯了先构建环境,然后期望团队自动凝聚在一起的错误。相反,应该首先致力于构建团队,然后再让团队基于需要来配置环境。
  ```

2. ***可以工作的软件胜过面面俱到的文档***
    
    ***文档应该简洁、突出重点，而不是复杂难以维护。*** 更期望使用代码和团队来传授知识。推荐：直到迫切需要并且意义重大时，才来编制文档。
    ```
    在给新的团队成员传授知识方面,最好的两份文档是代码和团队。代码真实地表达了它所做的事情。虽然从代码中提取系统的原理和结构信息可能是困难的,但是代码是惟一没有二义性的信息源。在团队成员的头脑中,保存着时常变化的系统的脉络图( road map)。人和人之间的交互是把这份脉络图传授给他人的最快、最有效的方式。

    ```
3.  ***客户合作胜过合同谈判***

    ***客户/产品和研发的频繁沟通要远胜于一纸合同/需求。*** 需求是不断变化的，成功的关键在于和客户/产品之间真诚的协作，并且合同/需求指导了这种协作,而不是试图去规定项目范围的细节和固定成本下的进度。
    ```
    成功的项目需要有序、频繁的客户反馈。不是依赖于合同或者关于工作的陈述,而是让软件的客户和开发团队密切地在一起工作,并尽量经常地提供反馈
    ```

4. ***响应变化胜过遵循计划***

    ***响应变化的能力常常决定着一个软件项目的成败。*** 当我们构建计划时,应该确保计划是灵活的并且易于适应商务和技术方面的变化。

    开发过程中需求的变化是非常频繁的，所以开发计划不可以太过长远，要保持足够的灵活度，较好的做计划的策略是：
    ```
    为下两周做详细的计划,为下三个月做粗略的计划,再以后就做极为粗糙的计划。我们应该清楚地知道下两周要完成的任务,粗略地了解一下以后三个月要实现的需求。至于系统一年后将要做什么,有一个模糊的想法就行了。

    计划中这种逐渐降低的细致度,意味着我们仅仅对于迫切的任务才花费时间进行详细的计划旦制定了这个详细的计划,就很难进行改变,因为团队会根据这个计划启动工作并有了相应的投然而,由于计划仅仅支配了几周的时间,计划的其余部分仍然保持着灵活性
    ```

### 1.2 原则
基于上述敏捷联盟的价值观，我们应该遵循以下原则

1. ***我们最优先要做的是通过尽早的、持续的交付有价值的软件来使客户满意***
2. ***即使到了开发的后期,也欢迎改变需求。敏捷过程利用变化来为客户创造竞争优势***
3. ***经常性地交付可以工作的软件,交付的间隔可以从几周到几个月,交付的时间间隔越短越好***
4. ***在整个项目开发期间,业务人员和开发人员必须天天都在一起工作***
5. ***围绕被激励起来的个人来构建项目。给他们提供所需要的环境和支持，并且信任他们能够完成工作***
6. ***在团队内部,最具有效果并且富有效率的传递信息的方法,就是面对面的交谈***
7. ***软件完成的功能数量是衡量进度的首要标准，而不是项目所处的阶段、文档数量亦或代码量***
8. ***敏捷过程提倡可持续的开发速度。责任人、开发者和用户应该能够保持一个长期的、恒定的开发速度***
9. ***不断地关注优秀的技能和好的设计会增强敏捷能力，尽力编写高质量代码，而不是为了赶进度堆屎山***
10. ***简单，以最高的质量完成最简单的工作。采用和目标一致的最简单的方法，而不是构建华而不实的系统***
11. ***最好的构架、需求和设计出自于自组织的团队，任务不是分配给团队的个人，而是整个团队***
    ```
    敏捷团队的成员共同来解决项目中所有方面的问题。每一个成员都具有项目中所有方面的参与权力。不存在单一的团队成员对系统构架、需求或者测试负责的情况。整个团队共同承担那些责任,每一个团队成员都能够影响它们。
    ```
12. ***每隔一定时间，团队会在如何才能更有效地工作方面进行反省，然后相应地对自己的行为进行调整***
    ```
    环境在不断变化，为了保持敏捷性，我们需要随环境一起变化
    ```

### 1.3 结论
每位软件开发人员、每一个开发团队的职业目标，都是给他们的雇主和客户交付最大可能的价值。可是，我们的项目以令人沮丧的速度失败，或者未能交付任何价值。虽然在项目中采用过程方法是出于好意的，但是膨胀的过程方法对于我们的失败至少是应该负一些责任的。敏捷软件开发的原则和价值观构成了一个可以帮助团队打破过程膨胀循环的方法，这个方法关注的是可以达到团队目标的一些简单的技术。

## 第二章 极限编程概述
上一章介绍了敏捷开发的价值观和原则，这一章介绍具体的实践方法 - 极限编程（XP）。

作为开发人员我们应该记住，极限编程（XP）是敏捷开发中最著名的一个，但并不是敏捷开发的唯一选择。

### 2.1 极限编程实践
1. ***客户/产品作为团队成员***
   
   我们希望客户/产品和开发在一起紧密的工作（例如在同一个房间），以便彼此知晓对方面临的问题，并共同去解决这些问题。

2. ***记录需求***
   
   我们需要知道需求存在很多细节，并且知道细节的大致分类，以至于可以做计划。但是不需要知道特定细节，需求的具体细节是和客户/产品在反复讨论的过程中记录下来的。

3. ***短交付周期***
   
   一般两周作为一次迭代，每次迭代是一个小的交付，迭代前确定好两周的需求细节，迭代开始不允许修改需求或者优先级。

   6次迭代作为一次发布，既一次较大的交付。根据每次发布的工作进度，来安排下一次发布的需求和优先级，争取可持续发展。

4. ***验收测试***

    验收测试要在需求交付之前编写完成，一个需求验收通过后就加入验收测试集合中，后续每次交付都要运行整个验收测试集合，出现失败则验收不通过。

5. ***结对编程***
   
   两个人用一个电脑开发，一个开发，一个实时review，保证至少每天互换一次角色。（据说不会降低开发效率，还会减少缺陷率，国内应该不适用）

6. ***测试驱动的开发方法***

    先编写测试用例，运行测试失败，然后根据测试用例开发功能；测试用例和代码开发的迭代一起进行，俗称测试驱动开发。由于这种方式强制要求各模块单独测试，有利于代码解耦合。

7. ***集体所有权***

    尽量让每个人熟悉每个模块，而不是每个人只对单独的模块负责，这样既可以扩宽团队成员的技术栈，降低编码厌倦，还可以应对人员流动带来的影响。

8. ***持续集成***

    推荐小而多的commit集成方式，而不是大而少的commit，团队成员保证每个commit编译通过，不影响其它同学checkout开发。保证各个模块的同学开发不互相阻塞。

    例如主分支master，a同学checkout出feat/a开发，b同学checkout出feat/b开发，其它同学也checkout出自己的开发分支开发，合入时，a同学开发完feat/a rebase master，修改冲突（如果有），合入master，其它同学开发完同样流程合入。

9. ***可持续的开发速度***

    除了版本发布的前一周，其他时间不提倡加班。开发是马拉松长跑，不是短跑，要保持稳定适中的速度可持续开发。（国内不适用）

10. ***开放的工作空间***

    团队成员在一个房间开发，互相可以听到沟通讨论声音，这种噪音不会影响开发速度，返而可以让其它同学及时知道你何时遇到了什么问题。积极讨论的屋子不会降低开发效率，反而会成倍提高。

11. ***计划游戏***

    产品/客户和研发分工明确，产品/客户负责决定需求的优先级，研发负责评估开发时间。在短周期迭代和频繁发布的背景下，双方互相磨合，对项目进度的把控更加准确。

12. ***简单的设计***
    不要着急引入基建，以最简单的方案实现第一批需求，只有在第一次需要时才引入。
    1. 考虑能够工作的最简单的方案。
    2. 拒绝重复代码

13. ***重构***

    随着需求的不断开发，代码会慢慢腐化，如果置之不理，最终会积重难返，屎山成堆。我们要持续的对代码进行重构，一点点修正腐化的代码，每次重构都要运行单元测试。

    重构就是在不改变代码行为的前提下，对其进行一系列小的改造，旨在改进系统结构的实践活动。每个改造都是微不足道的，几乎不值得去做。但是所有的这些改造叠加在一起，就形成了对系统设计和构架显著的改进。

14. ***隐喻（比较抽象，建议阅读原文）***
    
    隐喻，它是将整个系统联系在一起的全局视图；它是系统的未来景像，是它使得所有单独模块的位置和外观( shape)变得明显直观。如果模块的外观与整个系统的隐喻不符，那么你就知道该模块是错误的。
    
    隐喻通常可以归结为一个名字系统。这些名字提供了一个系统组成元素的词汇表,并且有助于定义它们之间关系。

### 2.2 结论

极限编程是一组简单、具体的实践，这些实践结合在一起形成了一个敏捷开发过程。该过程已
经被许多团队使用过，并且取得了好的效果。极限编程是一种优良的、通用的软件开发方法。项目
团队可以拿来直接采用，也可以增加一些实践，或者对其中的一些实践进行修改后再采用。

## 第五章 重构
关于重构相关的原则可以学习《重构，改善既有代码的设计》一书

在 Martin Fowler的名著《重构》一书中，他把重构(Refactoring)定义为:“在不改变代
码外在行为的前提下对代码做出修改,以改进代码的内部结构的过程。” 可是我们为什么要改进已
经能够工作的代码的结构呢？不是还有句古老的谚语，“如果它没有坏,就不要去修理它!”吗？

每一个软件模块都具有三项职责。第一个职责是它运行起来所完成的功能。这也是该模块得以
存在的原因。第二个职责是它要应对变化。几乎所有的模块在它们的生命周期中都要变化，开发者
有责任保证这种改变应该尽可能地简单。一个难以改变的模块是拙劣的,即使能够工作,也需要对
它进行修正。第三个职责是要和阅读它的人进行沟通。对该模块不熟悉的开发人员应该能够比较容
易地阅读并理解它。一个无法进行沟通的模块也是拙劣的，同样需要对它进行修正。

重构就好比用餐后对厨房的清理工作。第一次你没有清理它，你用餐是会快一点。但是由于没
有对盘碟和用餐环境进行清洁，第二天做准备工作的时间就要更长一点。这会再一次促使你放弃清
洁工作。的确，如果跳过清洁工作，你今天总是能够很快用完餐，但是脏乱在一天天的积累。最终，
你得花费大量的时间去寻找合适的烹饪器具，凿去盘碟上已经于硬的食物残余，并把它们洗擦干净
以使它们适合于烹饪。

饭是天天要吃的。忽略掉清洁工作并不能真正加快做饭速度。重构的目的，正像在本章中描述的，是为了每天清洁你的代码。我们不想让脏乱累积,我们不想“凿去并洗擦掉”随着时间累积的“干硬的”比特，我们想通过最小的努力就能够对我们的系统
进行扩展和修改。要想具有这种能力,最重要的就是要保持代码的清洁。

关于这一点，我怎么强调都不过分。本书中所有的原则和模式对于脏乱的代码来说将没有任何
价值。在学习原则和模式前，首先学习编写清洁的代码。

# 第二部分 敏捷设计
随着需求不断变更，代码的设计会慢慢散发出臭味，设计中的臭味是一种症状，是可以主观(如果不能客观的话)进行度量的。这些臭味常常是由于违反了设计原则中的一个或者多个而导致的。

***敏捷团队应用设计原则来除去臭味。***当没有臭味时，他们不会应用这些原则。仅仅因为是一个
原则就无条件的去遵循它的做法是错误的。这些原则不是可以随意在系统中到处喷洒的香水。过分
遵循这些原则会导致不必要的复杂性（Needless Complexity）的设计臭味。

设计臭味：
- 僵化性（Rigidity）:设计难以改变。
- 脆弱性（Fragility）:设计易于遭到破坏。
- 牢固性（Immobility）:设计难以重用。
- 粘滞性（Viscosity）:难以做正确的事情。
- 不必要的复杂性（Needless Complexity）:过分设计。
- 不必要的重复（Needless Repetition）:滥用鼠标。
- 晦涩性（Opacity）:混乱的表达

设计原则：

SOLID（单一职责、开闭原则、里氏替换、接口隔离以及依赖反转）稳定的

- 单一职责原则（The Single Responsibility Principle，简称SRP）
- 开放一封闭原则（The Open-Close Principle,简称OCP）
- Liskov替换原则（The Liskov Substitution Principle，简称LSP）
- 依赖倒置原则（The Dependency Inversion Principle，简称DIP）
- 接口隔离原则（The Interface Segregation Interface，简称ISP）

## 第七章 什么是敏捷设计
### 7.1 设计的臭味（屎山是如何堆成的）
1. 僵化性（它比我想象的要复杂得多）

僵化性是指难以对软件进行改动，即使是简单的改动。如果单一的改动会导致有依赖关系的模块中的连锁改动，那么设计就是僵化的。必须要改动的模块越多，设计就越僵化。

2. 脆弱性（这代码谁也不敢动，一动就出bug）

脆弱性是指，在进行一个改动时，程序的许多地方就可能出现问题。常常是，出现新问题的地方与改动的地方并没有概念上的关联。要修正这些问题就又会引出更多的问题，从而使开发团队就像一只不停追逐自己尾巴的狗一样(忙得团团转)。

3. 牢固性（这个模块已经有相关功能了，但是无法提取出来复用）

牢固性是指，设计中包含了对其他系统有用的部分，但是要把这些部分从系统中分离出来所需要的努力和风险是巨大的。这是一件令人遗憾的事，但却是非常常见的事情。

4. 粘滞性（我知道这样做是对的，但是很麻烦）

当面临一个改动时,开发人员常常发现会有多种改动的方法。其中，一些方法会保持设计；而另外一些会破坏设计(也就是生硬的手法)当那些可以保持系统设计的方法比那些生硬手法更难应用时，就表明设计具有高的粘滞性。做错误的事情是容易的,但是做正确的事情却很难。我们希望在软件设计中，可以容易地进行那些保持设计的变动。

5. 不必要的复杂性（为什么使用这个设计？以后可能会用到）

如果设计中包含有当前没有用的组成部分，它就含有不必要的复杂性。当开发人员预测需求的变化，并在软件中放置了处理那些潜在变化的代码时，常常会出现这种情况。

为过多的可能性做准备，致使设计中含有绝不会用到的结构，从而变得混乱。一些准备也许会带来回报，但是更多的不会。期间，设计背负着这些不会用到的部分，使软件变得复杂，并且难以理解。

6. 不必要的重复（这块代码我从某某那里copy过来的，我不知道为什么会有问题）

当系统中有重复的代码时，对系统进行改动会变得困难。在一个重复的代码体中发现的错误必须要在每个重复体中一一修正。不过，由于每个重复体之间都有细微的差别，所以修正的方式也不总是相同的。

7. 晦涩性（我在团队中是不可替代的，因为我写的代码别人看不懂）

晦涩性是指模块难以理解。代码可以用清晰、富有表现力的方式编写，或者可以用晦涩、费解的方式编写。代码随着时间而演化，往往会变得越来越晦涩。为了使代码的晦涩性保持最低，就需要持续地保持代码清晰并富有表现力。

### 7.4 保持尽可能好的设计
敏捷开发人员致力于保持设计尽可能地适当、干净。这不是一个随便的或者暂时性的承诺。敏捷开发人员不是每几周才清洁他们的设计。而是每天、每小时、甚至每分钟都要保持软件尽可能地干净、简单并富有表现力。他们从来不说，“稍后我们会回来修正它。” 他们决不让腐化出现。

敏捷开发人员对待软件设计的态度和外科医生对待消毒过程的态度是一样的。消毒过程使外科手术成为可能。没有它，被感染的风险之高是难以忍受的。敏捷开发人员对于他们的设计有同样的感觉。即使最小的腐化带来的风险也同样高到无法忍受。

设计必须要保持干净、简单，并且由于源代码是设计最重要的表示，所以它同样要保持干净。职业特性要求我们，作为软件开发人员,不能忍受代码腐化。

### 7.5 结论
敏捷设计是一个过程，不是一个事件。它是一个持续的应用原则、模式以及实践来改进软件的结构和可读性的过程。它致力于保持系统设计在任何时间都尽可能得简单、干净以及富有表现力。

在随后的章节中，我们会研究软件设计的一些原则和模式。在学习它们的时候，请记住，敏捷开发人员不会对一个庞大的预先设计应用那些原则和模式。相反，这些原则和模式被应用在一次次的迭代中，力图使代码以及代码所表达的设计保持干净。

## 第八章 单一职责原则（The Single Responsibility Principle，简称SRP）
```
就一个类而言，应该仅有一个引起它变化的原因
```
如果一个类承担的职责过多，就等于把这些职责耦合在了一起。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的(Fragile)设计，当变化发生时设计会遭受到意想不到的破坏。

SRP是所有原则中最简单的之一，也是最难正确运用的之一。我们会自然地把职责结合在一起。软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。事实上，我们将要论述的其余原则都会以这样或那样的方式回到这个问题上。

## 第九章 开放一封闭原则（The Open-Close Principle,简称OCP）
```
软件实体(类、模块、函数等等)应该是可以扩展的,但是不可修改的
```
如果程序中的一处改动就会产生连锁反应，导致一系列相关模块的改动，那么设计就具有僵化性的臭味。OCP建议我们应该对系统进行重构，这样以后对系统再进行那样的改动时，就不会导致更多的修改。如果正确地应用OCP，那么以后再进行同样的改动时，就只需要添加新的代码，而不必改动已经正常运行的代码。

遵循开放一封闭原则设计出的模块具有两个主要的特征。它们是:
- “对于扩展是开放的”(Open for extension)

    这意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。换句话说,我们可以改变模块的功能。

- “对于更改是封闭的”(Closed for modificaiton)
    
    对模块行为进行扩展时，不必改动模块的源代码或者二进制代码。模块的二迸制可执行版本，无论是可链接的库、DLL或者Java的ja文件，都无需改动这两个特征好像是互相矛盾的。扩展模块行为的通常方式就是修改该模块的源代码。不允许修改的模块常常都被认为是具有固定的行为。

***在不改变源代码的情况下更改它的行为，关键在于抽象和多态。***

在许多方面，OCP都是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处(也就是，灵活性、可重用性以及可维护性)。然而，并不是说只要使用一种面向对象语言就是遵循了这个原则。对于应用程序中的每个部分都肆意地进行抽象同样不是一个好主意。正确的做法是，开发人员应该仅仅对程序中呈现出频繁变化的那些部分做出抽象。拒绝不成熟的抽象和抽象本身一样重要。

## 第十章 Liskov替换原则（The Liskov Substitution Principle，简称LSP）
```
子类型(subtype)必须能够替换掉它们的基类型(base type)。
```
OCP是OOD中很多说法的核心。如果这个原则应用得有效，应用程序就会具有更多的可维护性、可重用性以及健壮性。LSP是使OCP成为可能的主要原则之一。正是子类型的可替换性才使得使用基类类型的模块在无需修改的情况下就可以扩展。这种可替换性必须是开发人员可以隐式依赖的东西。因此，如果没有显式地强制基类类型的契约，那么代码就必须良好地并且明显地表达出这
点

术语“Is-A”的含意过于宽泛以至于不能作为子类型的定义。子类型的正确定义是“可替换性的”，这里的可替换性可以通过显式或者隐式的契约来定义

## 第十一章 依赖倒置原则（The Dependency Inversion Principle，简称DIP）
```
a. 高层模埉不应该依赖于低层模块。二者都应该依赖于抽象
b. 抽象不应该依赖于细节。细节应该依赖于抽象
```
在这些年中，有许多人曾经问我为什么在这条原则的名字中使用“倒置”这个词。这是由于许多传统的软件开发方法，比如结构化分析和设计，总是倾向于创建一些高层模块依赖于低层模块、策略(policy)依赖于细节的软件结构。实际上这些方法的目的之一就是要定义子程序层次结构，该层次结构描述了髙层模块怎样调用低层模块。一个设计良好的面向对象的程序，其依赖程序结构相对于传统的过程式方法设计的通常结构而言就是被“倒置”了。

请考虑一下当高层模块依赖于低层模块时意味着什么。高层模块包含了一个应用程序中的重要的策略选择和业务模型。正是这些高层模块才使得其所在的应用程序区别于其他。然而，如果这些高层模块依赖亍低层模块，那么对低层模块的改动就会直接影响到髙层模块，从而迫使它们依次做出改动。这种情形是非常荒谬的!本应该是高层的策略设置模块去影响低层的细节实现模块的。包含高层业务规则的模块应该优先并独立于包含实现细节的模块。无论如何髙层模块都不应该依赖于低层模块。

此外，我们更希望能够重用的是高层的策略设置模块。我们已经非常擅长于通过子程序库的形式来重用低层模块。如果高层模块依赖于低层模块，那么在不同的上下文中重用髙层模块就会变得非常困难。然而，如果髙层模块独立于低层模块，那么髙层模块就可以非常容易地被重用。该原则是框架(framework)设计的核心原则。

### 依赖于抽象
一个稍微简单但仍然非常有效的对于DP的解释，是这样一个简单的启发式规则:“依赖于抽象。”

这是一个简单的陈述，该启发式规则建议不应该依赖于具体类——也就是说,程序中所有的依赖关系都应该终止于抽象类或者接口。

根据这个启发式规则,可知
- 任何变量都不应该持有一个指向具体类的指针或者引用
- 任何类都不应该从具体类派生
- 任何方法都不应该覆写它的任何基类中的已经实现了的方法

### 结论
使用传统的过程化程序设计所创建出来的依赖关系结构，策略是依赖于细节的。这是糟糕的，因为这样会使策略受到细节改变的影响。面向对象的程序设计倒置了依赖关系结构，使得细节和策略都依赖于抽象,并且常常是客户拥有服务接口。

事实上，这种依赖关系的倒置正是好的面向对象设计的标志所在。使用何种语言来编写程序是无关紧要的。如果程序的依赖关系是倒置的，它就是面向对象的设计。如果程序的依赖关系不是倒置的，它就是过程化的设计。

依赖倒置原则是实现许多面向对象技术所宣称的好处的基本低层机制。它的正确应用对于创建可重用的框架来说是必须的。同时它对于构建在变化面前富有弹性的代码也是非常重要的。由于抽象和细节被彼此隔离，所以代码也非常容易维护。
## 第十二章 接口隔离原则（The Interface Segregation Interface，简称ISP）
```
不应该强迫客户依赖于它们不用的方法
```
如果强迫客户程序依赖于那些它们不使用的方法，那么这些客户程序就面临着由于这些未使用方法的改变所带来的变更。这无意中导致了所有客户程序之间的耦合。换种说法，如果一个客户程序依赖于一个含有它不使用的方法的类，但是其他客户程序却要使用该方法，那么当其他客户要求这个类改变时，就会影响到这个客户程序。我们希望尽可能地避免这种耦合，因此我们希望分离接口。

### 总结
胖类(fat class)会导致它们的客户程序之间产生不正常的并且有害的耦合关系。当一个客户程序要求该胖类进行一个改动时，会影响到所有其他的客户程序。因此，客户程序应该仅仅依赖于它们实际调用的方法。通过把胖类的接口分解为多个特定于客户程序的接口，可以实现这个目标。每个特定于客户程序的接口仅仅声明它的特定客户或者客户组调用的那些函数。接着，该胖类就可以继承所有特定于客户程序的接口，并实现它们。这就解除了客户程序和它们没有调用的方法间的依赖关系，并使客户程序之间互不依赖。

# 设计模式
[图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/index.html)
[图说设计模式实现](https://github1s.com/jaredtao/DesignPattern/blob/HEAD/CMakeLists.txt)
